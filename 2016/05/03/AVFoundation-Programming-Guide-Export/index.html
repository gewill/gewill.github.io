<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="ExportTo read and write audiovisual assets, you must use the export APIs provided by the AVFoundation framework. The AVAssetExportSession class provides an interface for simple exporting needs, such a">
<meta property="og:type" content="article">
<meta property="og:title" content="AVFoundation Programming Guide - Export">
<meta property="og:url" content="http://example.com/2016/05/03/AVFoundation-Programming-Guide-Export/index.html">
<meta property="og:site_name" content="Will&#39;s Blog">
<meta property="og:description" content="ExportTo read and write audiovisual assets, you must use the export APIs provided by the AVFoundation framework. The AVAssetExportSession class provides an interface for simple exporting needs, such a">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2016-05-03T08:48:00.000Z">
<meta property="article:modified_time" content="2025-01-13T03:01:04.057Z">
<meta property="article:author" content="Ge Will">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2016/05/03/AVFoundation-Programming-Guide-Export/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2016/05/03/AVFoundation-Programming-Guide-Export/","path":"2016/05/03/AVFoundation-Programming-Guide-Export/","title":"AVFoundation Programming Guide - Export"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>AVFoundation Programming Guide - Export | Will's Blog</title>
  







<head>
    <!-- 霞鹜文楷字体 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css"/>

    <!-- datapulse统计 -->
    <script defer type="text/javascript" src="https://datapulse.app/datapulse.min.js" id="datapulse" data-endpoint="https://datapulse.app/api/v1/event" data-workspace="cljxqml5q0y0f8j37d4futnbl"></script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DR0FC9YJLH"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'G-DR0FC9YJLH');
    </script>
</head>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Will's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">198</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">17</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">1</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Export"><span class="nav-number">1.</span> <span class="nav-text">Export</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Reading-an-Asset"><span class="nav-number">1.1.</span> <span class="nav-text">1. Reading an Asset</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Creating-the-Asset-Reader"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1. Creating the Asset Reader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Setting-Up-the-Asset-Reader-Outputs"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2. Setting Up the Asset Reader Outputs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Reading-the-Asset%E2%80%99s-Media-Data"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3. Reading the Asset’s Media Data</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Writing-an-Asset"><span class="nav-number">1.2.</span> <span class="nav-text">2. Writing an Asset</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Creating-the-Asset-Writer"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1. Creating the Asset Writer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Setting-Up-the-Asset-Writer-Inputs"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2. Setting Up the Asset Writer Inputs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Writing-Media-Data"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3. Writing Media Data</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Reencoding-Assets"><span class="nav-number">1.3.</span> <span class="nav-text">3. Reencoding Assets</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Putting-It-All-Together-Using-an-Asset-Reader-and-Writer-in-Tandem-to-Reencode-an-Asset"><span class="nav-number">1.4.</span> <span class="nav-text">4. Putting It All Together: Using an Asset Reader and Writer in Tandem to Reencode an Asset</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Handling-the-Initial-Setup"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1. Handling the Initial Setup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Initializing-the-Asset-Reader-and-Writer"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2. Initializing the Asset Reader and Writer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Reencoding-the-Asset"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3. Reencoding the Asset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-Handling-Completion"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4. Handling Completion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-Handling-Cancellation"><span class="nav-number">1.4.5.</span> <span class="nav-text">4.5. Handling Cancellation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Asset-Output-Settings-Assistant"><span class="nav-number">1.5.</span> <span class="nav-text">5. Asset Output Settings Assistant</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Demo"><span class="nav-number">1.6.</span> <span class="nav-text">Demo</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ge Will"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Ge Will</p>
  <div class="site-description" itemprop="description">The people who are crazy enough to think they can change the world, are the ones who DO.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">198</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/gewill" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gewill" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:531sunlight@gmail.com" title="E-Mail → mailto:531sunlight@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/gewei" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;gewei" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/BoJack_D" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;BoJack_D" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/05/03/AVFoundation-Programming-Guide-Export/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Ge Will">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will's Blog">
      <meta itemprop="description" content="The people who are crazy enough to think they can change the world, are the ones who DO.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="AVFoundation Programming Guide - Export | Will's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AVFoundation Programming Guide - Export
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2016-05-03 16:48:00" itemprop="dateCreated datePublished" datetime="2016-05-03T16:48:00+08:00">2016-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-01-13 11:01:04" itemprop="dateModified" datetime="2025-01-13T11:01:04+08:00">2025-01-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Export"><a href="#Export" class="headerlink" title="Export"></a>Export</h1><p>To read and write audiovisual assets, you must use the export APIs provided by the AVFoundation framework. The AVAssetExportSession class provides an interface for simple exporting needs, such as modifying the file format or trimming the length of an asset (see Trimming and Transcoding a Movie). For more in-depth exporting needs, use the AVAssetReader and AVAssetWriter classes.</p>
<p>Use an AVAssetReader when you want to perform an operation on the contents of an asset. For example, you might read the audio track of an asset to produce a visual representation of the waveform. To produce an asset from media such as sample buffers or still images, use an AVAssetWriter object.</p>
<blockquote>
<p>Note: The asset reader and writer classes are not intended to be used for real-time processing. In fact, an asset reader cannot even be used for reading from a real-time source like an HTTP live stream. However, if you are using an asset writer with a real-time data source, such as an AVCaptureOutput object, set the expectsMediaDataInRealTime property of your asset writer’s inputs to YES. Setting this property to YES for a non-real-time data source will result in your files not being interleaved properly.</p>
</blockquote>
<h2 id="1-Reading-an-Asset"><a href="#1-Reading-an-Asset" class="headerlink" title="1. Reading an Asset"></a>1. Reading an Asset</h2><p>Each AVAssetReader object can be associated only with a single asset at a time, but this asset may contain multiple tracks. For this reason, you must assign concrete subclasses of the AVAssetReaderOutput class to your asset reader before you begin reading in order to configure how the media data is read. There are three concrete subclasses of the AVAssetReaderOutput base class that you can use for your asset reading needs: AVAssetReaderTrackOutput, AVAssetReaderAudioMixOutput, and AVAssetReaderVideoCompositionOutput.</p>
<h3 id="1-1-Creating-the-Asset-Reader"><a href="#1-1-Creating-the-Asset-Reader" class="headerlink" title="1.1. Creating the Asset Reader"></a>1.1. Creating the Asset Reader</h3><p>All you need to initialize an AVAssetReader object is the asset that you want to read.</p>
<p>直接初始化即可，是一个可失败的构造器，注意检查是否成功。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *outError;</span><br><span class="line"><span class="built_in">AVAsset</span> *someAsset = &lt;#<span class="built_in">AVAsset</span> that you want to read#&gt;;</span><br><span class="line"><span class="built_in">AVAssetReader</span> *assetReader = [<span class="built_in">AVAssetReader</span> assetReaderWithAsset:someAsset error:&amp;outError];</span><br><span class="line"><span class="type">BOOL</span> success = (assetReader != <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: Always check that the asset reader returned to you is non-nil to ensure that the asset reader was initialized successfully. Otherwise, the error parameter (outError in the previous example) will contain the relevant error information.</p>
</blockquote>
<h3 id="1-2-Setting-Up-the-Asset-Reader-Outputs"><a href="#1-2-Setting-Up-the-Asset-Reader-Outputs" class="headerlink" title="1.2. Setting Up the Asset Reader Outputs"></a>1.2. Setting Up the Asset Reader Outputs</h3><p>After you have created your asset reader, set up at least one output to receive the media data being read. When setting up your outputs, be sure to set the alwaysCopiesSampleData property to NO. In this way, you reap the benefits of performance improvements. In all of the examples within this chapter, this property could and should be set to NO.</p>
<p>alwaysCopiesSampleData 设置 NO，来获取性能的提升。</p>
<p>If you want only to read media data from one or more tracks and potentially convert that data to a different format, use the AVAssetReaderTrackOutput class, using a single track output object for each AVAssetTrack object that you want to read from your asset. To decompress an audio track to Linear PCM with an asset reader, you set up your track output as follows:</p>
<p>设置 track output</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *localAsset = assetReader.asset;</span><br><span class="line"><span class="comment">// Get the audio track to read.</span></span><br><span class="line"><span class="built_in">AVAssetTrack</span> *audioTrack = [[localAsset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="comment">// Decompression settings for Linear PCM</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *decompressionAudioSettings = @&#123; <span class="built_in">AVFormatIDKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatLinearPCM] &#125;;</span><br><span class="line"><span class="comment">// Create the output with the audio track and decompression settings.</span></span><br><span class="line"><span class="built_in">AVAssetReaderOutput</span> *trackOutput = [<span class="built_in">AVAssetReaderTrackOutput</span> assetReaderTrackOutputWithTrack:audioTrack outputSettings:decompressionAudioSettings];</span><br><span class="line"><span class="comment">// Add the output to the reader if possible.</span></span><br><span class="line"><span class="keyword">if</span> ([assetReader canAddOutput:trackOutput])</span><br><span class="line">    [assetReader addOutput:trackOutput];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: To read the media data from a specific asset track in the format in which it was stored, pass nil to the outputSettings parameter.</p>
</blockquote>
<p>You use the AVAssetReaderAudioMixOutput and AVAssetReaderVideoCompositionOutput classes to read media data that has been mixed or composited together using an AVAudioMix object or AVVideoComposition object, respectively. Typically, these outputs are used when your asset reader is reading from an AVComposition object.</p>
<p>With a single audio mix output, you can read multiple audio tracks from your asset that have been mixed together using an AVAudioMix object. To specify how the audio tracks are mixed, assign the mix to the AVAssetReaderAudioMixOutput object after initialization. The following code displays how to create an audio mix output with all of the audio tracks from your asset, decompress the audio tracks to Linear PCM, and assign an audio mix object to the output. For details on how to configure an audio mix, see Editing.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAudioMix</span> *audioMix = &lt;#An <span class="built_in">AVAudioMix</span> that specifies how the audio tracks from the <span class="built_in">AVAsset</span> are mixed#&gt;;</span><br><span class="line"><span class="comment">// Assumes that assetReader was initialized with an AVComposition object.</span></span><br><span class="line"><span class="built_in">AVComposition</span> *composition = (<span class="built_in">AVComposition</span> *)assetReader.asset;</span><br><span class="line"><span class="comment">// Get the audio tracks to read.</span></span><br><span class="line"><span class="built_in">NSArray</span> *audioTracks = [composition tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>];</span><br><span class="line"><span class="comment">// Get the decompression settings for Linear PCM.</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *decompressionAudioSettings = @&#123; <span class="built_in">AVFormatIDKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatLinearPCM] &#125;;</span><br><span class="line"><span class="comment">// Create the audio mix output with the audio tracks and decompression setttings.</span></span><br><span class="line"><span class="built_in">AVAssetReaderOutput</span> *audioMixOutput = [<span class="built_in">AVAssetReaderAudioMixOutput</span> assetReaderAudioMixOutputWithAudioTracks:audioTracks audioSettings:decompressionAudioSettings];</span><br><span class="line"><span class="comment">// Associate the audio mix used to mix the audio tracks being read with the output.</span></span><br><span class="line">audioMixOutput.audioMix = audioMix;</span><br><span class="line"><span class="comment">// Add the output to the reader if possible.</span></span><br><span class="line"><span class="keyword">if</span> ([assetReader canAddOutput:audioMixOutput])</span><br><span class="line">    [assetReader addOutput:audioMixOutput];</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: Passing nil for the audioSettings parameter tells the asset reader to return samples in a convenient uncompressed format. The same is true for the AVAssetReaderVideoCompositionOutput class.</p>
</blockquote>
<p>The video composition output behaves in much the same way: You can read multiple video tracks from your asset that have been composited together using an AVVideoComposition object. To read the media data from multiple composited video tracks and decompress it to ARGB, set up your output as follows:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVVideoComposition</span> *videoComposition = &lt;#An <span class="built_in">AVVideoComposition</span> that specifies how the video tracks from the <span class="built_in">AVAsset</span> are composited#&gt;;</span><br><span class="line"><span class="comment">// Assumes assetReader was initialized with an AVComposition.</span></span><br><span class="line"><span class="built_in">AVComposition</span> *composition = (<span class="built_in">AVComposition</span> *)assetReader.asset;</span><br><span class="line"><span class="comment">// Get the video tracks to read.</span></span><br><span class="line"><span class="built_in">NSArray</span> *videoTracks = [composition tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"><span class="comment">// Decompression settings for ARGB.</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *decompressionVideoSettings = @&#123; (<span class="type">id</span>)kCVPixelBufferPixelFormatTypeKey : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kCVPixelFormatType_32ARGB], (<span class="type">id</span>)kCVPixelBufferIOSurfacePropertiesKey : [<span class="built_in">NSDictionary</span> dictionary] &#125;;</span><br><span class="line"><span class="comment">// Create the video composition output with the video tracks and decompression setttings.</span></span><br><span class="line"><span class="built_in">AVAssetReaderOutput</span> *videoCompositionOutput = [<span class="built_in">AVAssetReaderVideoCompositionOutput</span> assetReaderVideoCompositionOutputWithVideoTracks:videoTracks videoSettings:decompressionVideoSettings];</span><br><span class="line"><span class="comment">// Associate the video composition used to composite the video tracks being read with the output.</span></span><br><span class="line">videoCompositionOutput.videoComposition = videoComposition;</span><br><span class="line"><span class="comment">// Add the output to the reader if possible.</span></span><br><span class="line"><span class="keyword">if</span> ([assetReader canAddOutput:videoCompositionOutput])</span><br><span class="line">    [assetReader addOutput:videoCompositionOutput];</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="1-3-Reading-the-Asset’s-Media-Data"><a href="#1-3-Reading-the-Asset’s-Media-Data" class="headerlink" title="1.3. Reading the Asset’s Media Data"></a>1.3. Reading the Asset’s Media Data</h3><p>To start reading after setting up all of the outputs you need, call the startReading method on your asset reader. Next, retrieve the media data individually from each output using the copyNextSampleBuffer method. To start up an asset reader with a single output and read all of its media samples, do the following:</p>
<p>使用 copyNextSampleBuffer 方法获取 CMSampleBufferRef：一个抽象类，封装了零或多个媒体类型的小样。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the asset reader up.</span></span><br><span class="line">[<span class="keyword">self</span>.assetReader startReading];</span><br><span class="line"><span class="type">BOOL</span> done = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">while</span> (!done)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Copy the next sample buffer from the reader output.</span></span><br><span class="line">  <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderOutput copyNextSampleBuffer];</span><br><span class="line">  <span class="keyword">if</span> (sampleBuffer)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Do something with sampleBuffer here.</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">    sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Find out why the asset reader output couldn&#x27;t copy another sample buffer.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.assetReader.status == <span class="built_in">AVAssetReaderStatusFailed</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">NSError</span> *failureError = <span class="keyword">self</span>.assetReader.error;</span><br><span class="line">      <span class="comment">// Handle the error here.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// The asset reader output has read all of its samples.</span></span><br><span class="line">      done = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Writing-an-Asset"><a href="#2-Writing-an-Asset" class="headerlink" title="2. Writing an Asset"></a>2. Writing an Asset</h2><p>The AVAssetWriter class to write media data from multiple sources to a single file of a specified file format. You don’t need to associate your asset writer object with a specific asset, but you must use a separate asset writer for each output file that you want to create. Because an asset writer can write media data from multiple sources, you must create an AVAssetWriterInput object for each individual track that you want to write to the output file. Each AVAssetWriterInput object expects to receive data in the form of CMSampleBufferRef objects, but if you want to append CVPixelBufferRef objects to your asset writer input, use the AVAssetWriterInputPixelBufferAdaptor class.</p>
<blockquote>
<p>CVPixelBufferRef: A reference to a Core Video pixel buffer object. The pixel buffer stores an image in main memory.</p>
</blockquote>
<h3 id="2-1-Creating-the-Asset-Writer"><a href="#2-1-Creating-the-Asset-Writer" class="headerlink" title="2.1. Creating the Asset Writer"></a>2.1. Creating the Asset Writer</h3><p>To create an asset writer, specify the URL for the output file and the desired file type. The following code displays how to initialize an asset writer to create a QuickTime movie:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *outError;</span><br><span class="line"><span class="built_in">NSURL</span> *outputURL = &lt;#<span class="built_in">NSURL</span> object representing the URL where you want to save the video#&gt;;</span><br><span class="line"><span class="built_in">AVAssetWriter</span> *assetWriter = [<span class="built_in">AVAssetWriter</span> assetWriterWithURL:outputURL</span><br><span class="line">                                                      fileType:<span class="built_in">AVFileTypeQuickTimeMovie</span></span><br><span class="line">                                                         error:&amp;outError];</span><br><span class="line"><span class="type">BOOL</span> success = (assetWriter != <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Setting-Up-the-Asset-Writer-Inputs"><a href="#2-2-Setting-Up-the-Asset-Writer-Inputs" class="headerlink" title="2.2. Setting Up the Asset Writer Inputs"></a>2.2. Setting Up the Asset Writer Inputs</h3><p>For your asset writer to be able to write media data, you must set up at least one asset writer input. For example, if your source of media data is already vending media samples as CMSampleBufferRef objects, just use the AVAssetWriterInput class. To set up an asset writer input that compresses audio media data to 128 kbps AAC and connect it to your asset writer, do the following:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configure the channel layout as stereo.</span></span><br><span class="line">AudioChannelLayout stereoChannelLayout = &#123;</span><br><span class="line">    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,</span><br><span class="line">    .mChannelBitmap = <span class="number">0</span>,</span><br><span class="line">    .mNumberChannelDescriptions = <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Convert the channel layout object to an NSData object.</span></span><br><span class="line"><span class="built_in">NSData</span> *channelLayoutAsData = [<span class="built_in">NSData</span> dataWithBytes:&amp;stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Get the compression settings for 128 kbps AAC.</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *compressionAudioSettings = @&#123;</span><br><span class="line">    <span class="built_in">AVFormatIDKey</span>         : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatMPEG4AAC],</span><br><span class="line">    <span class="built_in">AVEncoderBitRateKey</span>   : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">128000</span>],</span><br><span class="line">    <span class="built_in">AVSampleRateKey</span>       : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">44100</span>],</span><br><span class="line">    <span class="built_in">AVChannelLayoutKey</span>    : channelLayoutAsData,</span><br><span class="line">    <span class="built_in">AVNumberOfChannelsKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInteger:<span class="number">2</span>]</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create the asset writer input with the compression settings and specify the media type as audio.</span></span><br><span class="line"><span class="built_in">AVAssetWriterInput</span> *assetWriterInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="built_in">AVMediaTypeAudio</span> outputSettings:compressionAudioSettings];</span><br><span class="line"><span class="comment">// Add the input to the writer if possible.</span></span><br><span class="line"><span class="keyword">if</span> ([assetWriter canAddInput:assetWriterInput])</span><br><span class="line">    [assetWriter addInput:assetWriterInput];</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: If you want the media data to be written in the format in which it was stored, pass nil in the outputSettings parameter. Pass nil only if the asset writer was initialized with a fileType of AVFileTypeQuickTimeMovie.</p>
</blockquote>
<p>Your asset writer input can optionally include some metadata or specify a different transform for a particular track using the metadata and transform properties respectively. For an asset writer input whose data source is a video track, you can maintain the video’s original transform in the output file by doing the following:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *videoAsset = &lt;#<span class="built_in">AVAsset</span> with at least one video track#&gt;;</span><br><span class="line"><span class="built_in">AVAssetTrack</span> *videoAssetTrack = [[videoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line">assetWriterInput.transform = videoAssetTrack.preferredTransform;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: Set the metadata and transform properties before you begin writing with your asset writer for them to take effect.</p>
</blockquote>
<p>When writing media data to the output file, sometimes you may want to allocate pixel buffers. To do so, use the AVAssetWriterInputPixelBufferAdaptor class. For greatest efficiency, instead of adding pixel buffers that were allocated using a separate pool, use the pixel buffer pool provided by the pixel buffer adaptor. The following code creates a pixel buffer object working in the RGB domain that will use CGImage objects to create its pixel buffers.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *pixelBufferAttributes = @&#123;</span><br><span class="line">     kCVPixelBufferCGImageCompatibilityKey : [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>],</span><br><span class="line">     kCVPixelBufferCGBitmapContextCompatibilityKey : [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>],</span><br><span class="line">     kCVPixelBufferPixelFormatTypeKey : [<span class="built_in">NSNumber</span> numberWithInt:kCVPixelFormatType_32ARGB]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">AVAssetWriterInputPixelBufferAdaptor</span> *inputPixelBufferAdaptor = [<span class="built_in">AVAssetWriterInputPixelBufferAdaptor</span> assetWriterInputPixelBufferAdaptorWithAssetWriterInput:<span class="keyword">self</span>.assetWriterInput sourcePixelBufferAttributes:pixelBufferAttributes];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: All AVAssetWriterInputPixelBufferAdaptor objects must be connected to a single asset writer input. That asset writer input must accept media data of type AVMediaTypeVideo.</p>
</blockquote>
<h3 id="2-3-Writing-Media-Data"><a href="#2-3-Writing-Media-Data" class="headerlink" title="2.3. Writing Media Data"></a>2.3. Writing Media Data</h3><p>When you have configured all of the inputs needed for your asset writer, you are ready to begin writing media data. As you did with the asset reader, initiate the writing process with a call to the startWriting method. You then need to start a sample-writing session with a call to the startSessionAtSourceTime: method. All writing done by an asset writer has to occur within one of these sessions and the time range of each session defines the time range of media data included from within the source. For example, if your source is an asset reader that is supplying media data read from an AVAsset object and you don’t want to include media data from the first half of the asset, you would do the following:</p>
<p>配置完就是开始了：startWriting，和上面的 reader 用法基本一致。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMTime</span> halfAssetDuration = <span class="built_in">CMTimeMultiplyByFloat64</span>(<span class="keyword">self</span>.asset.duration, <span class="number">0.5</span>);</span><br><span class="line">[<span class="keyword">self</span>.assetWriter startSessionAtSourceTime:halfAssetDuration];</span><br><span class="line"><span class="comment">//Implementation continues.</span></span><br></pre></td></tr></table></figure>

<p>Normally, to end a writing session you must call the endSessionAtSourceTime: method. However, if your writing session goes right up to the end of your file, you can end the writing session simply by calling the finishWriting method. To start up an asset writer with a single input and write all of its media data, do the following:</p>
<p>两种方法都可以结束 writing session：endSessionAtSourceTime 和 finishWriting</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prepare the asset writer for writing.</span></span><br><span class="line">[<span class="keyword">self</span>.assetWriter startWriting];</span><br><span class="line"><span class="comment">// Start a sample-writing session.</span></span><br><span class="line">[<span class="keyword">self</span>.assetWriter startSessionAtSourceTime:kCMTimeZero];</span><br><span class="line"><span class="comment">// Specify the block to execute when the asset writer is ready for media data and the queue to call it on.</span></span><br><span class="line">[<span class="keyword">self</span>.assetWriterInput requestMediaDataWhenReadyOnQueue:myInputSerialQueue usingBlock:^&#123;</span><br><span class="line">     <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterInput isReadyForMoreMediaData])</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// Get the next sample buffer.</span></span><br><span class="line">          <span class="built_in">CMSampleBufferRef</span> nextSampleBuffer = [<span class="keyword">self</span> copyNextSampleBufferToWrite];</span><br><span class="line">          <span class="keyword">if</span> (nextSampleBuffer)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If it exists, append the next sample buffer to the output file.</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterInput appendSampleBuffer:nextSampleBuffer];</span><br><span class="line">               <span class="built_in">CFRelease</span>(nextSampleBuffer);</span><br><span class="line">               nextSampleBuffer = <span class="literal">nil</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// Assume that lack of a next sample buffer means the sample buffer source is out of samples and mark the input as finished.</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterInput markAsFinished];</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>The copyNextSampleBufferToWrite method in the code above is simply a stub. The location of this stub is where you would need to insert some logic to return CMSampleBufferRef objects representing the media data that you want to write. One possible source of sample buffers is an asset reader output.</p>
<p>这里的copyNextSampleBufferToWrite只是一个存根，你有必要在这里进行了一下逻辑上的处理。</p>
<h2 id="3-Reencoding-Assets"><a href="#3-Reencoding-Assets" class="headerlink" title="3. Reencoding Assets"></a>3. Reencoding Assets</h2><p>重新编码</p>
<p>You can use an asset reader and asset writer object in tandem to convert an asset from one representation to another. Using these objects, you have more control over the conversion than you do with an AVAssetExportSession object. For example, you can choose which of the tracks you want to be represented in the output file, specify your own output format, or modify the asset during the conversion process. The first step in this process is just to set up your asset reader outputs and asset writer inputs as desired. After your asset reader and writer are fully configured, you start up both of them with calls to the startReading and startWriting methods, respectively. The following code snippet displays how to use a single asset writer input to write media data supplied by a single asset reader output:</p>
<p>同时使用 asset reader 和 writer 可以用来转换编辑格式。而且比AVAssetExportSession有更多选项可控：指定自己的输出格式、处理中更改 asset。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *serializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create a serialization queue for reading and writing.</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serializationQueue = dispatch_queue_create([serializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Specify the block to execute when the asset writer is ready for media data and the queue to call it on.</span></span><br><span class="line">[<span class="keyword">self</span>.assetWriterInput requestMediaDataWhenReadyOnQueue:serializationQueue usingBlock:^&#123;</span><br><span class="line">     <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterInput isReadyForMoreMediaData])</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// Get the asset reader output&#x27;s next sample buffer.</span></span><br><span class="line">          <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderOutput copyNextSampleBuffer];</span><br><span class="line">          <span class="keyword">if</span> (sampleBuffer != <span class="literal">NULL</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If it exists, append this sample buffer to the output file.</span></span><br><span class="line">               <span class="type">BOOL</span> success = [<span class="keyword">self</span>.assetWriterInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">               <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">               sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">               <span class="comment">// Check for errors that may have occurred when appending the new sample buffer.</span></span><br><span class="line">               <span class="keyword">if</span> (!success &amp;&amp; <span class="keyword">self</span>.assetWriter.status == <span class="built_in">AVAssetWriterStatusFailed</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="built_in">NSError</span> *failureError = <span class="keyword">self</span>.assetWriter.error;</span><br><span class="line">                    <span class="comment">//Handle the error.</span></span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If the next sample buffer doesn&#x27;t exist, find out why the asset reader output couldn&#x27;t vend another one.</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">self</span>.assetReader.status == <span class="built_in">AVAssetReaderStatusFailed</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="built_in">NSError</span> *failureError = <span class="keyword">self</span>.assetReader.error;</span><br><span class="line">                    <span class="comment">//Handle the error here.</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="comment">// The asset reader output must have vended all of its samples. Mark the input as finished.</span></span><br><span class="line">                    [<span class="keyword">self</span>.assetWriterInput markAsFinished];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="4-Putting-It-All-Together-Using-an-Asset-Reader-and-Writer-in-Tandem-to-Reencode-an-Asset"><a href="#4-Putting-It-All-Together-Using-an-Asset-Reader-and-Writer-in-Tandem-to-Reencode-an-Asset" class="headerlink" title="4. Putting It All Together: Using an Asset Reader and Writer in Tandem to Reencode an Asset"></a>4. Putting It All Together: Using an Asset Reader and Writer in Tandem to Reencode an Asset</h2><p>This brief code example illustrates how to use an asset reader and writer to reencode the first video and audio track of an asset into a new file. It shows how to:</p>
<ul>
<li>Use serialization queues to handle the asynchronous nature of reading and writing audiovisual data 使用串行队列来调度异步处理读写媒体数据</li>
<li>Initialize an asset reader and configure two asset reader outputs, one for audio and one for video 初始化 reader 并配置两个输出源</li>
<li>Initialize an asset writer and configure two asset writer inputs, one for audio and one for video 初始化 writer 并配置两个输出源</li>
<li>Use an asset reader to asynchronously supply media data to an asset writer through two different output&#x2F;input combinations 使用一个 reader 来异步提供媒体数据给 writer </li>
<li>Use a dispatch group to be notified of completion of the reencoding process 使用一个 dispatch group 来通知重新编码的进度</li>
<li>Allow a user to cancel the reencoding process once it has begun 允许用户取消操作</li>
</ul>
<blockquote>
<p>Note: To focus on the most relevant code, this example omits several aspects of a complete application. To use AVFoundation, you are expected to have enough experience with Cocoa to be able to infer the missing pieces.</p>
</blockquote>
<h3 id="4-1-Handling-the-Initial-Setup"><a href="#4-1-Handling-the-Initial-Setup" class="headerlink" title="4.1. Handling the Initial Setup"></a>4.1. Handling the Initial Setup</h3><p>Before you create your asset reader and writer and configure their outputs and inputs, you need to handle some initial setup. The first part of this setup involves creating three separate serialization queues to coordinate the reading and writing process.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *serializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create the main serialization queue.</span></span><br><span class="line"><span class="keyword">self</span>.mainSerializationQueue = dispatch_queue_create([serializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">NSString</span> *rwAudioSerializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ rw audio serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create the serialization queue to use for reading and writing the audio data.</span></span><br><span class="line"><span class="keyword">self</span>.rwAudioSerializationQueue = dispatch_queue_create([rwAudioSerializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">NSString</span> *rwVideoSerializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ rw video serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create the serialization queue to use for reading and writing the video data.</span></span><br><span class="line"><span class="keyword">self</span>.rwVideoSerializationQueue = dispatch_queue_create([rwVideoSerializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>The main serialization queue is used to coordinate the starting and stopping of the asset reader and writer (perhaps due to cancellation) and the other two serialization queues are used to serialize the reading and writing by each output&#x2F;input combination with a potential cancellation.</p>
<p>主队列用来定位 reader 和 writer 的开始和结束，另外连个队列用来调度读写的输入输出源的联合体以及潜在的取消操作。</p>
<p>Now that you have some serialization queues, load the tracks of your asset and begin the reencoding process.</p>
<p>有了队列，就可以加载 asset 中的 tracks 并开始重新编码的进程了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.asset = &lt;#<span class="built_in">AVAsset</span> that you want to reencode#&gt;;</span><br><span class="line"><span class="keyword">self</span>.cancelled = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">self</span>.outputURL = &lt;#<span class="built_in">NSURL</span> representing desired output URL <span class="keyword">for</span> file generated by asset writer#&gt;;</span><br><span class="line"><span class="comment">// Asynchronously load the tracks of the asset you want to read.</span></span><br><span class="line">[<span class="keyword">self</span>.asset loadValuesAsynchronouslyForKeys:@[<span class="string">@&quot;tracks&quot;</span>] completionHandler:^&#123;</span><br><span class="line">     <span class="comment">// Once the tracks have finished loading, dispatch the work to the main serialization queue.</span></span><br><span class="line">     <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.mainSerializationQueue, ^&#123;</span><br><span class="line">          <span class="comment">// Due to asynchronous nature, check to see if user has already cancelled.</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.cancelled)</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">          <span class="type">BOOL</span> success = <span class="literal">YES</span>;</span><br><span class="line">          <span class="built_in">NSError</span> *localError = <span class="literal">nil</span>;</span><br><span class="line">          <span class="comment">// Check for success of loading the assets tracks.</span></span><br><span class="line">          success = ([<span class="keyword">self</span>.asset statusOfValueForKey:<span class="string">@&quot;tracks&quot;</span> error:&amp;localError] == <span class="built_in">AVKeyValueStatusLoaded</span>);</span><br><span class="line">          <span class="keyword">if</span> (success)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If the tracks loaded successfully, make sure that no file exists at the output path for the asset writer.</span></span><br><span class="line">               <span class="built_in">NSFileManager</span> *fm = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">               <span class="built_in">NSString</span> *localOutputPath = [<span class="keyword">self</span>.outputURL path];</span><br><span class="line">               <span class="keyword">if</span> ([fm fileExistsAtPath:localOutputPath])</span><br><span class="line">                    success = [fm removeItemAtPath:localOutputPath error:&amp;localError];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (success)</span><br><span class="line">               success = [<span class="keyword">self</span> setupAssetReaderAndAssetWriter:&amp;localError];</span><br><span class="line">          <span class="keyword">if</span> (success)</span><br><span class="line">               success = [<span class="keyword">self</span> startAssetReaderAndWriter:&amp;localError];</span><br><span class="line">          <span class="keyword">if</span> (!success)</span><br><span class="line">               [<span class="keyword">self</span> readingAndWritingDidFinishSuccessfully:success withError:localError];</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>When the track loading process finishes, whether successfully or not, the rest of the work is dispatched to the main serialization queue to ensure that all of this work is serialized with a potential cancellation. Now all that’s left is to implement the cancellation process and the three custom methods at the end of the previous code listing.</p>
<h3 id="4-2-Initializing-the-Asset-Reader-and-Writer"><a href="#4-2-Initializing-the-Asset-Reader-and-Writer" class="headerlink" title="4.2. Initializing the Asset Reader and Writer"></a>4.2. Initializing the Asset Reader and Writer</h3><p>The custom setupAssetReaderAndAssetWriter: method initializes the reader and writer and configures two output&#x2F;input combinations, one for an audio track and one for a video track. In this example, the audio is decompressed to Linear PCM using the asset reader and compressed back to 128 kbps AAC using the asset writer. The video is decompressed to YUV using the asset reader and compressed to H.264 using the asset writer.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)setupAssetReaderAndAssetWriter:(<span class="built_in">NSError</span> **)outError</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// Create and initialize the asset reader.</span></span><br><span class="line">     <span class="keyword">self</span>.assetReader = [[<span class="built_in">AVAssetReader</span> alloc] initWithAsset:<span class="keyword">self</span>.asset error:outError];</span><br><span class="line">     <span class="type">BOOL</span> success = (<span class="keyword">self</span>.assetReader != <span class="literal">nil</span>);</span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the asset reader was successfully initialized, do the same for the asset writer.</span></span><br><span class="line">          <span class="keyword">self</span>.assetWriter = [[<span class="built_in">AVAssetWriter</span> alloc] initWithURL:<span class="keyword">self</span>.outputURL fileType:<span class="built_in">AVFileTypeQuickTimeMovie</span> error:outError];</span><br><span class="line">          success = (<span class="keyword">self</span>.assetWriter != <span class="literal">nil</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the reader and writer were successfully initialized, grab the audio and video asset tracks that will be used.</span></span><br><span class="line">          <span class="built_in">AVAssetTrack</span> *assetAudioTrack = <span class="literal">nil</span>, *assetVideoTrack = <span class="literal">nil</span>;</span><br><span class="line">          <span class="built_in">NSArray</span> *audioTracks = [<span class="keyword">self</span>.asset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>];</span><br><span class="line">          <span class="keyword">if</span> ([audioTracks count] &gt; <span class="number">0</span>)</span><br><span class="line">               assetAudioTrack = [audioTracks objectAtIndex:<span class="number">0</span>];</span><br><span class="line">          <span class="built_in">NSArray</span> *videoTracks = [<span class="keyword">self</span>.asset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line">          <span class="keyword">if</span> ([videoTracks count] &gt; <span class="number">0</span>)</span><br><span class="line">               assetVideoTrack = [videoTracks objectAtIndex:<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">if</span> (assetAudioTrack)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If there is an audio track to read, set the decompression settings to Linear PCM and create the asset reader output.</span></span><br><span class="line">               <span class="built_in">NSDictionary</span> *decompressionAudioSettings = @&#123; <span class="built_in">AVFormatIDKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatLinearPCM] &#125;;</span><br><span class="line">               <span class="keyword">self</span>.assetReaderAudioOutput = [<span class="built_in">AVAssetReaderTrackOutput</span> assetReaderTrackOutputWithTrack:assetAudioTrack outputSettings:decompressionAudioSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetReader addOutput:<span class="keyword">self</span>.assetReaderAudioOutput];</span><br><span class="line">               <span class="comment">// Then, set the compression settings to 128kbps AAC and create the asset writer input.</span></span><br><span class="line">               AudioChannelLayout stereoChannelLayout = &#123;</span><br><span class="line">                    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,</span><br><span class="line">                    .mChannelBitmap = <span class="number">0</span>,</span><br><span class="line">                    .mNumberChannelDescriptions = <span class="number">0</span></span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="built_in">NSData</span> *channelLayoutAsData = [<span class="built_in">NSData</span> dataWithBytes:&amp;stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];</span><br><span class="line">               <span class="built_in">NSDictionary</span> *compressionAudioSettings = @&#123;</span><br><span class="line">                    <span class="built_in">AVFormatIDKey</span>         : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatMPEG4AAC],</span><br><span class="line">                    <span class="built_in">AVEncoderBitRateKey</span>   : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">128000</span>],</span><br><span class="line">                    <span class="built_in">AVSampleRateKey</span>       : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">44100</span>],</span><br><span class="line">                    <span class="built_in">AVChannelLayoutKey</span>    : channelLayoutAsData,</span><br><span class="line">                    <span class="built_in">AVNumberOfChannelsKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInteger:<span class="number">2</span>]</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="keyword">self</span>.assetWriterAudioInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:[assetAudioTrack mediaType] outputSettings:compressionAudioSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetWriter addInput:<span class="keyword">self</span>.assetWriterAudioInput];</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">if</span> (assetVideoTrack)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If there is a video track to read, set the decompression settings for YUV and create the asset reader output.</span></span><br><span class="line">               <span class="built_in">NSDictionary</span> *decompressionVideoSettings = @&#123;</span><br><span class="line">                    (<span class="type">id</span>)kCVPixelBufferPixelFormatTypeKey     : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kCVPixelFormatType_422YpCbCr8],</span><br><span class="line">                    (<span class="type">id</span>)kCVPixelBufferIOSurfacePropertiesKey : [<span class="built_in">NSDictionary</span> dictionary]</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="keyword">self</span>.assetReaderVideoOutput = [<span class="built_in">AVAssetReaderTrackOutput</span> assetReaderTrackOutputWithTrack:assetVideoTrack outputSettings:decompressionVideoSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetReader addOutput:<span class="keyword">self</span>.assetReaderVideoOutput];</span><br><span class="line">               <span class="built_in">CMFormatDescriptionRef</span> formatDescription = <span class="literal">NULL</span>;</span><br><span class="line">               <span class="comment">// Grab the video format descriptions from the video track and grab the first one if it exists.</span></span><br><span class="line">               <span class="built_in">NSArray</span> *videoFormatDescriptions = [assetVideoTrack formatDescriptions];</span><br><span class="line">               <span class="keyword">if</span> ([videoFormatDescriptions count] &gt; <span class="number">0</span>)</span><br><span class="line">                    formatDescription = (__bridge <span class="built_in">CMFormatDescriptionRef</span>)[formatDescriptions objectAtIndex:<span class="number">0</span>];</span><br><span class="line">               <span class="built_in">CGSize</span> trackDimensions = &#123;</span><br><span class="line">                    .width = <span class="number">0.0</span>,</span><br><span class="line">                    .height = <span class="number">0.0</span>,</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="comment">// If the video track had a format description, grab the track dimensions from there. Otherwise, grab them direcly from the track itself.</span></span><br><span class="line">               <span class="keyword">if</span> (formatDescription)</span><br><span class="line">                    trackDimensions = <span class="built_in">CMVideoFormatDescriptionGetPresentationDimensions</span>(formatDescription, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                    trackDimensions = [assetVideoTrack naturalSize];</span><br><span class="line">               <span class="built_in">NSDictionary</span> *compressionSettings = <span class="literal">nil</span>;</span><br><span class="line">               <span class="comment">// If the video track had a format description, attempt to grab the clean aperture settings and pixel aspect ratio used by the video.</span></span><br><span class="line">               <span class="keyword">if</span> (formatDescription)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="built_in">NSDictionary</span> *cleanAperture = <span class="literal">nil</span>;</span><br><span class="line">                    <span class="built_in">NSDictionary</span> *pixelAspectRatio = <span class="literal">nil</span>;</span><br><span class="line">                    <span class="built_in">CFDictionaryRef</span> cleanApertureFromCMFormatDescription = <span class="built_in">CMFormatDescriptionGetExtension</span>(formatDescription, kCMFormatDescriptionExtension_CleanAperture);</span><br><span class="line">                    <span class="keyword">if</span> (cleanApertureFromCMFormatDescription)</span><br><span class="line">                    &#123;</span><br><span class="line">                         cleanAperture = @&#123;</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureWidthKey</span>            : (<span class="type">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureWidth),</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureHeightKey</span>           : (<span class="type">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureHeight),</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureHorizontalOffsetKey</span> : (<span class="type">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureHorizontalOffset),</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureVerticalOffsetKey</span>   : (<span class="type">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureVerticalOffset)</span><br><span class="line">                         &#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">CFDictionaryRef</span> pixelAspectRatioFromCMFormatDescription = <span class="built_in">CMFormatDescriptionGetExtension</span>(formatDescription, kCMFormatDescriptionExtension_PixelAspectRatio);</span><br><span class="line">                    <span class="keyword">if</span> (pixelAspectRatioFromCMFormatDescription)</span><br><span class="line">                    &#123;</span><br><span class="line">                         pixelAspectRatio = @&#123;</span><br><span class="line">                              <span class="built_in">AVVideoPixelAspectRatioHorizontalSpacingKey</span> : (<span class="type">id</span>)<span class="built_in">CFDictionaryGetValue</span>(pixelAspectRatioFromCMFormatDescription, kCMFormatDescriptionKey_PixelAspectRatioHorizontalSpacing),</span><br><span class="line">                              <span class="built_in">AVVideoPixelAspectRatioVerticalSpacingKey</span>   : (<span class="type">id</span>)<span class="built_in">CFDictionaryGetValue</span>(pixelAspectRatioFromCMFormatDescription, kCMFormatDescriptionKey_PixelAspectRatioVerticalSpacing)</span><br><span class="line">                         &#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Add whichever settings we could grab from the format description to the compression settings dictionary.</span></span><br><span class="line">                    <span class="keyword">if</span> (cleanAperture || pixelAspectRatio)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="built_in">NSMutableDictionary</span> *mutableCompressionSettings = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">                         <span class="keyword">if</span> (cleanAperture)</span><br><span class="line">                              [mutableCompressionSettings setObject:cleanAperture forKey:<span class="built_in">AVVideoCleanApertureKey</span>];</span><br><span class="line">                         <span class="keyword">if</span> (pixelAspectRatio)</span><br><span class="line">                              [mutableCompressionSettings setObject:pixelAspectRatio forKey:<span class="built_in">AVVideoPixelAspectRatioKey</span>];</span><br><span class="line">                         compressionSettings = mutableCompressionSettings;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Create the video settings dictionary for H.264.</span></span><br><span class="line">               <span class="built_in">NSMutableDictionary</span> *videoSettings = (<span class="built_in">NSMutableDictionary</span> *) @&#123;</span><br><span class="line">                    <span class="built_in">AVVideoCodecKey</span>  : <span class="built_in">AVVideoCodecH264</span>,</span><br><span class="line">                    <span class="built_in">AVVideoWidthKey</span>  : [<span class="built_in">NSNumber</span> numberWithDouble:trackDimensions.width],</span><br><span class="line">                    <span class="built_in">AVVideoHeightKey</span> : [<span class="built_in">NSNumber</span> numberWithDouble:trackDimensions.height]</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="comment">// Put the compression settings into the video settings dictionary if we were able to grab them.</span></span><br><span class="line">               <span class="keyword">if</span> (compressionSettings)</span><br><span class="line">                    [videoSettings setObject:compressionSettings forKey:<span class="built_in">AVVideoCompressionPropertiesKey</span>];</span><br><span class="line">               <span class="comment">// Create the asset writer input and add it to the asset writer.</span></span><br><span class="line">               <span class="keyword">self</span>.assetWriterVideoInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:[videoTrack mediaType] outputSettings:videoSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetWriter addInput:<span class="keyword">self</span>.assetWriterVideoInput];</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Reencoding-the-Asset"><a href="#4-3-Reencoding-the-Asset" class="headerlink" title="4.3. Reencoding the Asset"></a>4.3. Reencoding the Asset</h3><p>Provided that the asset reader and writer are successfully initialized and configured, the startAssetReaderAndWriter: method described in Handling the Initial Setup is called. This method is where the actual reading and writing of the asset takes place.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)startAssetReaderAndWriter:(<span class="built_in">NSError</span> **)outError</span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">BOOL</span> success = <span class="literal">YES</span>;</span><br><span class="line">     <span class="comment">// Attempt to start the asset reader.</span></span><br><span class="line">     success = [<span class="keyword">self</span>.assetReader startReading];</span><br><span class="line">     <span class="keyword">if</span> (!success)</span><br><span class="line">          *outError = [<span class="keyword">self</span>.assetReader error];</span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the reader started successfully, attempt to start the asset writer.</span></span><br><span class="line">          success = [<span class="keyword">self</span>.assetWriter startWriting];</span><br><span class="line">          <span class="keyword">if</span> (!success)</span><br><span class="line">               *outError = [<span class="keyword">self</span>.assetWriter error];</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the asset reader and writer both started successfully, create the dispatch group where the reencoding will take place and start a sample-writing session.</span></span><br><span class="line">          <span class="keyword">self</span>.dispatchGroup = dispatch_group_create();</span><br><span class="line">          [<span class="keyword">self</span>.assetWriter startSessionAtSourceTime:kCMTimeZero];</span><br><span class="line">          <span class="keyword">self</span>.audioFinished = <span class="literal">NO</span>;</span><br><span class="line">          <span class="keyword">self</span>.videoFinished = <span class="literal">NO</span>;</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterAudioInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If there is audio to reencode, enter the dispatch group before beginning the work.</span></span><br><span class="line">               dispatch_group_enter(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               <span class="comment">// Specify the block to execute when the asset writer is ready for audio media data, and specify the queue to call it on.</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterAudioInput requestMediaDataWhenReadyOnQueue:<span class="keyword">self</span>.rwAudioSerializationQueue usingBlock:^&#123;</span><br><span class="line">                    <span class="comment">// Because the block is called asynchronously, check to see whether its task is complete.</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span>.audioFinished)</span><br><span class="line">                         <span class="keyword">return</span>;</span><br><span class="line">                    <span class="type">BOOL</span> completedOrFailed = <span class="literal">NO</span>;</span><br><span class="line">                    <span class="comment">// If the task isn&#x27;t complete yet, make sure that the input is actually ready for more media data.</span></span><br><span class="line">                    <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterAudioInput isReadyForMoreMediaData] &amp;&amp; !completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Get the next audio sample buffer, and append it to the output file.</span></span><br><span class="line">                         <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderAudioOutput copyNextSampleBuffer];</span><br><span class="line">                         <span class="keyword">if</span> (sampleBuffer != <span class="literal">NULL</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              <span class="type">BOOL</span> success = [<span class="keyword">self</span>.assetWriterAudioInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">                              <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">                              sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                              completedOrFailed = !success;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">else</span></span><br><span class="line">                         &#123;</span><br><span class="line">                              completedOrFailed = <span class="literal">YES</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Mark the input as finished, but only if we haven&#x27;t already done so, and then leave the dispatch group (since the audio work has finished).</span></span><br><span class="line">                         <span class="type">BOOL</span> oldFinished = <span class="keyword">self</span>.audioFinished;</span><br><span class="line">                         <span class="keyword">self</span>.audioFinished = <span class="literal">YES</span>;</span><br><span class="line">                         <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              [<span class="keyword">self</span>.assetWriterAudioInput markAsFinished];</span><br><span class="line">                         &#125;</span><br><span class="line">                         dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;];</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterVideoInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If we had video to reencode, enter the dispatch group before beginning the work.</span></span><br><span class="line">               dispatch_group_enter(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               <span class="comment">// Specify the block to execute when the asset writer is ready for video media data, and specify the queue to call it on.</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterVideoInput requestMediaDataWhenReadyOnQueue:<span class="keyword">self</span>.rwVideoSerializationQueue usingBlock:^&#123;</span><br><span class="line">                    <span class="comment">// Because the block is called asynchronously, check to see whether its task is complete.</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span>.videoFinished)</span><br><span class="line">                         <span class="keyword">return</span>;</span><br><span class="line">                    <span class="type">BOOL</span> completedOrFailed = <span class="literal">NO</span>;</span><br><span class="line">                    <span class="comment">// If the task isn&#x27;t complete yet, make sure that the input is actually ready for more media data.</span></span><br><span class="line">                    <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterVideoInput isReadyForMoreMediaData] &amp;&amp; !completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Get the next video sample buffer, and append it to the output file.</span></span><br><span class="line">                         <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderVideoOutput copyNextSampleBuffer];</span><br><span class="line">                         <span class="keyword">if</span> (sampleBuffer != <span class="literal">NULL</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              <span class="type">BOOL</span> success = [<span class="keyword">self</span>.assetWriterVideoInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">                              <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">                              sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                              completedOrFailed = !success;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">else</span></span><br><span class="line">                         &#123;</span><br><span class="line">                              completedOrFailed = <span class="literal">YES</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Mark the input as finished, but only if we haven&#x27;t already done so, and then leave the dispatch group (since the video work has finished).</span></span><br><span class="line">                         <span class="type">BOOL</span> oldFinished = <span class="keyword">self</span>.videoFinished;</span><br><span class="line">                         <span class="keyword">self</span>.videoFinished = <span class="literal">YES</span>;</span><br><span class="line">                         <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              [<span class="keyword">self</span>.assetWriterVideoInput markAsFinished];</span><br><span class="line">                         &#125;</span><br><span class="line">                         dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Set up the notification that the dispatch group will send when the audio and video work have both finished.</span></span><br><span class="line">          dispatch_group_notify(<span class="keyword">self</span>.dispatchGroup, <span class="keyword">self</span>.mainSerializationQueue, ^&#123;</span><br><span class="line">               <span class="type">BOOL</span> finalSuccess = <span class="literal">YES</span>;</span><br><span class="line">               <span class="built_in">NSError</span> *finalError = <span class="literal">nil</span>;</span><br><span class="line">               <span class="comment">// Check to see if the work has finished due to cancellation.</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">self</span>.cancelled)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="comment">// If so, cancel the reader and writer.</span></span><br><span class="line">                    [<span class="keyword">self</span>.assetReader cancelReading];</span><br><span class="line">                    [<span class="keyword">self</span>.assetWriter cancelWriting];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="comment">// If cancellation didn&#x27;t occur, first make sure that the asset reader didn&#x27;t fail.</span></span><br><span class="line">                    <span class="keyword">if</span> ([<span class="keyword">self</span>.assetReader status] == <span class="built_in">AVAssetReaderStatusFailed</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                         finalSuccess = <span class="literal">NO</span>;</span><br><span class="line">                         finalError = [<span class="keyword">self</span>.assetReader error];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// If the asset reader didn&#x27;t fail, attempt to stop the asset writer and check for any errors.</span></span><br><span class="line">                    <span class="keyword">if</span> (finalSuccess)</span><br><span class="line">                    &#123;</span><br><span class="line">                         finalSuccess = [<span class="keyword">self</span>.assetWriter finishWriting];</span><br><span class="line">                         <span class="keyword">if</span> (!finalSuccess)</span><br><span class="line">                              finalError = [<span class="keyword">self</span>.assetWriter error];</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Call the method to handle completion, and pass in the appropriate parameters to indicate whether reencoding was successful.</span></span><br><span class="line">               [<span class="keyword">self</span> readingAndWritingDidFinishSuccessfully:finalSuccess withError:finalError];</span><br><span class="line">          &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// Return success here to indicate whether the asset reader and writer were started successfully.</span></span><br><span class="line">     <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>During reencoding, the audio and video tracks are asynchronously handled on individual serialization queues to increase the overall performance of the process, but both queues are contained within the same dispatch group. By placing the work for each track within the same dispatch group, the group can send a notification when all of the work is done and the success of the reencoding process can be determined.</p>
<p>音频和视频 track 在各自队列里异步的处理，又在同一个队列组中，这样方便获取编码 成功的通知。</p>
<h3 id="4-4-Handling-Completion"><a href="#4-4-Handling-Completion" class="headerlink" title="4.4. Handling Completion"></a>4.4. Handling Completion</h3><p>To handle the completion of the reading and writing process, the readingAndWritingDidFinishSuccessfully: method is called—with parameters indicating whether or not the reencoding completed successfully. If the process didn’t finish successfully, the asset reader and writer are both canceled and any UI related tasks are dispatched to the main queue.</p>
<p>处理完成时：进度和是否成功。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)readingAndWritingDidFinishSuccessfully:(<span class="type">BOOL</span>)success withError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (!success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the reencoding process failed, we need to cancel the asset reader and writer.</span></span><br><span class="line">          [<span class="keyword">self</span>.assetReader cancelReading];</span><br><span class="line">          [<span class="keyword">self</span>.assetWriter cancelWriting];</span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               <span class="comment">// Handle any UI tasks here related to failure.</span></span><br><span class="line">          &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// Reencoding was successful, reset booleans.</span></span><br><span class="line">          <span class="keyword">self</span>.cancelled = <span class="literal">NO</span>;</span><br><span class="line">          <span class="keyword">self</span>.videoFinished = <span class="literal">NO</span>;</span><br><span class="line">          <span class="keyword">self</span>.audioFinished = <span class="literal">NO</span>;</span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               <span class="comment">// Handle any UI tasks here related to success.</span></span><br><span class="line">          &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-5-Handling-Cancellation"><a href="#4-5-Handling-Cancellation" class="headerlink" title="4.5. Handling Cancellation"></a>4.5. Handling Cancellation</h3><p>Using multiple serialization queues, you can allow the user of your app to cancel the reencoding process with ease. On the main serialization queue, messages are asynchronously sent to each of the asset reencoding serialization queues to cancel their reading and writing. When these two serialization queues complete their cancellation, the dispatch group sends a notification to the main serialization queue where the cancelled property is set to YES. You might associate the cancel method from the following code listing with a button on your UI.</p>
<p>处理取消操作</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)cancel</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// Handle cancellation asynchronously, but serialize it with the main queue.</span></span><br><span class="line">     <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.mainSerializationQueue, ^&#123;</span><br><span class="line">          <span class="comment">// If we had audio data to reencode, we need to cancel the audio work.</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterAudioInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// Handle cancellation asynchronously again, but this time serialize it with the audio queue.</span></span><br><span class="line">               <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.rwAudioSerializationQueue, ^&#123;</span><br><span class="line">                    <span class="comment">// Update the Boolean property indicating the task is complete and mark the input as finished if it hasn&#x27;t already been marked as such.</span></span><br><span class="line">                    <span class="type">BOOL</span> oldFinished = <span class="keyword">self</span>.audioFinished;</span><br><span class="line">                    <span class="keyword">self</span>.audioFinished = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                         [<span class="keyword">self</span>.assetWriterAudioInput markAsFinished];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Leave the dispatch group since the audio work is finished now.</span></span><br><span class="line">                    dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               &#125;);</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterVideoInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// Handle cancellation asynchronously again, but this time serialize it with the video queue.</span></span><br><span class="line">               <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.rwVideoSerializationQueue, ^&#123;</span><br><span class="line">                    <span class="comment">// Update the Boolean property indicating the task is complete and mark the input as finished if it hasn&#x27;t already been marked as such.</span></span><br><span class="line">                    <span class="type">BOOL</span> oldFinished = <span class="keyword">self</span>.videoFinished;</span><br><span class="line">                    <span class="keyword">self</span>.videoFinished = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                         [<span class="keyword">self</span>.assetWriterVideoInput markAsFinished];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Leave the dispatch group, since the video work is finished now.</span></span><br><span class="line">                    dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Set the cancelled Boolean property to YES to cancel any work on the main queue as well.</span></span><br><span class="line">          <span class="keyword">self</span>.cancelled = <span class="literal">YES</span>;</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-Asset-Output-Settings-Assistant"><a href="#5-Asset-Output-Settings-Assistant" class="headerlink" title="5. Asset Output Settings Assistant"></a>5. Asset Output Settings Assistant</h2><p>The AVOutputSettingsAssistant class aids in creating output-settings dictionaries for an asset reader or writer. This makes setup much simpler, especially for high frame rate H264 movies that have a number of specific presets. Listing 5-1 shows an example that uses the output settings assistant to use the settings assistant.</p>
<p>资源输出源设置助手</p>
<p>Listing 5-1  AVOutputSettingsAssistant sample</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVOutputSettingsAssistant</span> *outputSettingsAssistant = [<span class="built_in">AVOutputSettingsAssistant</span> outputSettingsAssistantWithPreset:&lt;some preset&gt;];</span><br><span class="line"><span class="built_in">CMFormatDescriptionRef</span> audioFormat = [<span class="keyword">self</span> getAudioFormat];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (audioFormat != <span class="literal">NULL</span>)</span><br><span class="line">    [outputSettingsAssistant setSourceAudioFormat:(<span class="built_in">CMAudioFormatDescriptionRef</span>)audioFormat];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">CMFormatDescriptionRef</span> videoFormat = [<span class="keyword">self</span> getVideoFormat];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (videoFormat != <span class="literal">NULL</span>)</span><br><span class="line">    [outputSettingsAssistant setSourceVideoFormat:(<span class="built_in">CMVideoFormatDescriptionRef</span>)videoFormat];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">CMTime</span> assetMinVideoFrameDuration = [<span class="keyword">self</span> getMinFrameDuration];</span><br><span class="line"><span class="built_in">CMTime</span> averageFrameDuration = [<span class="keyword">self</span> getAvgFrameDuration]</span><br><span class="line"> </span><br><span class="line">[outputSettingsAssistant setSourceVideoAverageFrameDuration:averageFrameDuration];</span><br><span class="line">[outputSettingsAssistant setSourceVideoMinFrameDuration:assetMinVideoFrameDuration];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">AVAssetWriter</span> *assetWriter = [<span class="built_in">AVAssetWriter</span> assetWriterWithURL:&lt;some URL&gt; fileType:[outputSettingsAssistant outputFileType] error:<span class="literal">NULL</span>];</span><br><span class="line"><span class="built_in">AVAssetWriterInput</span> *audioInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="built_in">AVMediaTypeAudio</span> outputSettings:[outputSettingsAssistant audioSettings] sourceFormatHint:audioFormat];</span><br><span class="line"><span class="built_in">AVAssetWriterInput</span> *videoInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="built_in">AVMediaTypeVideo</span> outputSettings:[outputSettingsAssistant videoSettings] sourceFormatHint:videoFormat];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>AVReaderWriter: Offline Audio &#x2F; Video Processing:<br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/samplecode/ReaderWriter/Introduction/Intro.html">https://developer.apple.com/library/mac/samplecode/ReaderWriter/Introduction/Intro.html</a></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2016/04/28/Core-Data-Notes/" rel="prev" title="Core Data - Notes">
                  <i class="fa fa-chevron-left"></i> Core Data - Notes
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2016/05/16/Transforming-Arrays/" rel="next" title="转换数组">
                  转换数组 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Ge Will</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
